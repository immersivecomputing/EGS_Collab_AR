<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EGS Collab AR</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
		.label {
				color: #FFF;
				font-family: sans-serif;
				padding: 2px;
				background: rgba( 0, 0, 0, .6 );
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">EGS Collab</a> AR <br/>
		</div>
		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { ARButton } from './jsm/webxr/ARButton.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './jsm/environments/RoomEnvironment.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import {csvParse} from "https://cdn.skypack.dev/d3-dsv@3";
			import { Lut } from './jsm/math/Lut.js';
			import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';

			let container;
			let camera, scene, renderer, loadedModel;
			let controller, lut;
			let meshSpline, raycaster, sphereInter;
			const pointer = new THREE.Vector2();
			
			let reticle;
			let planes;
			
			let csvData, labelRenderer, labelDiv, valueLabel;
			let baseNorthing, baseEasting, baseElev;

			let hitTestSource = null;
			let hitTestSourceRequested = false;
			
			let boreholeSpline, tubeGeometry;
			const material = new THREE.MeshLambertMaterial( {
					side: THREE.DoubleSide,
					color: 0xF5F5F5,
					vertexColors: true} );
			let materialModel;
					
			
			const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.3, wireframe: true, transparent: true } );

			const params = {
				toggleTunnel: true,
				toggleGrid: false,
                toggleBoreholes: false,
                toggleElectrodes: false,
                toggleGyroStartPoints: false,
                toggleGyroSrikeDipDepth: false,
                toggleGyroXYZ: false,
				textField: "E2-TC",
				loadCSV: loadCSV,
				planeY: {

					constant: -0.5,
					//negated: false,
					//displayHelper: false

				}
				};

			init();
			animate();
			
			

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				renderer.localClippingEnabled = true;
				container.appendChild( renderer.domElement );
				
				
				planes = [
					new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), -0.5 )
				];
				
				materialModel = new THREE.MeshLambertMaterial( {

							color: 0xB6D7A8,
							opacity: 0.25,
							transparent: true,
							side: THREE.DoubleSide,
							clippingPlanes: planes,

						} );
				
				lut = new Lut();
				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 50 );
				camera.position.set( 0, 7, 0 );
				
				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				
				scene = new THREE.Scene();
				loadedModel = new THREE.Group();
				//scene.background = new THREE.Color( 0xbbbbbb );
				//scene.environment = pmremGenerator.fromScene( environment ).texture;
				
				scene.background = null;
				scene.environment = null;
				
				const light = new THREE.HemisphereLight( 0xffffff, 0x080808, 1.5 );
				light.position.set( -1.25, 1, 1.25 );
				scene.add( light );
				

				const grid = new THREE.GridHelper( 10, 100, 0xffffff, 0xffffff );
				grid.material.opacity = 0.5;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				grid.visible = false;
				scene.add( grid );
				
				const loader = new GLTFLoader().setPath( '/EGS_Collab_AR/GLTF/' );
				loader.load('EGS_Collab.gltf', function ( gltf ){
							loadedModel.add(gltf.scene);
							loadedModel.scale.set(0.01,0.01,0.01)
							scene.add(loadedModel);
							ToggleValue(false,'BoreholesOnly');
							ToggleValue(false,'Electrodes');
							ToggleValue(false,'Gyro_StartingPoints');
							ToggleValue(false,'Gyro_XYZPoints');
							ToggleValue(false,'Gyro_StrikeDipDepthPoints');
							render();
						});
				
				

				document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

				function onSelect() {

					if ( reticle.visible ) {
						
						loadedModel.position.setFromMatrixPosition( reticle.matrix );
						loadedModel.scale.set(0.005,0.005,0.005);
						render();
					}
				}
				

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'select', onSelect );
				scene.add( controller );

				reticle = new THREE.Mesh(
					new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial()
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add( reticle );


				window.addEventListener( 'resize', onWindowResize );
				
				
				//Load some buffer geometries
				
				loadModel( 'SampleBufferGeometry2.json');
				loadModel( 'SampleBufferGeometry1.json');
				loadModel( 'SampleBufferGeometry.json');
				//
				
				const gui = new GUI();
				const baseFolder = gui.addFolder( 'Base Objects' );
				baseFolder.add(params, 'toggleTunnel').name('Tunnel').onChange( function (value){
					ToggleValue(value,'TunnelOnly');
				});
				baseFolder.add(params, 'toggleGrid').name('Grid').onChange( function (value){
					grid.visible = value;
					render();
				});
				const planningFolder = gui.addFolder( 'Planned Positions' );
				planningFolder.add(params, 'toggleBoreholes').name('Boreholes').onChange( function (value){
					ToggleValue(value,'BoreholesOnly');
				});
				planningFolder.add(params, 'toggleElectrodes').name('Electrodes').onChange( function (value){
					ToggleValue(value,'Electrodes');
				});
				const gyroFolder = gui.addFolder( 'Gyro Data' );
                gyroFolder.add(params, 'toggleGyroStartPoints' ).name( 'Start Points' ).onChange( function (value){
					ToggleValue(value,'Gyro_StartingPoints');
				});
                gyroFolder.add(params, 'toggleGyroSrikeDipDepth' ).name( 'Strike/Dip/Depth Points' ).onChange( function (value){
					ToggleValue(value,'Gyro_XYZPoints');
				});
                gyroFolder.add(params, 'toggleGyroXYZ' ).name( 'XYZ Points' ).onChange( function (value){
					ToggleValue(value,'Gyro_StrikeDipDepthPoints');
				});
				
				const importFolder = gui.addFolder( 'Import Gyro Data' );
				importFolder.add(params, "textField").name('File Name');
				importFolder.add(params, "loadCSV").name('Load CSV');
				const planeY = gui.addFolder( 'Clip Plane Y' );
				//planeY.add( params.planeY, 'displayHelper' ).onChange( v => planeHelpers[ 1 ].visible = v );
				planeY.add( params.planeY, 'constant' ).min( -0.5 ).max( 2 ).onChange( d => planes[ 0 ].constant = d );
				//planeY.add( params.planeY, 'negated' ).onChange( () => {
					//planes[ 1 ].negate();
					//params.planeY.constant = planes[ 1 ].constant;
				//} );
				
				const sphgeometry = new THREE.SphereGeometry( 2.5 );
				const sphmaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				sphereInter = new THREE.Mesh( sphgeometry, sphmaterial );
				sphereInter.visible = false;
				
				loadedModel.add( sphereInter );
				raycaster = new THREE.Raycaster();
				document.addEventListener( 'pointermove', onPointerMove );
				
				labelDiv = document.createElement( 'div' );
				labelDiv.className = 'label';
				labelDiv.textContent = '-';
				labelDiv.style.marginTop = '-1em';
				valueLabel = new CSS2DObject( labelDiv );
				valueLabel.position.set( 0, 1, 0 );
				valueLabel.visible = false;
				sphereInter.add( valueLabel );
				
				labelRenderer = new CSS2DRenderer();
				labelRenderer.setSize( window.innerWidth, window.innerHeight );
				labelRenderer.domElement.style.position = 'absolute';
				labelRenderer.domElement.style.top = '0px';
				document.body.appendChild( labelRenderer.domElement );
				
				const controls = new OrbitControls( camera, labelRenderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.01;
				controls.maxDistance = 1000;
				controls.target.set( 0, 0, 0 );
				controls.update();
				
			}
			
			function ToggleValue(value, valueName) {
				loadedModel.traverse( function ( child ) {
					if ( child instanceof THREE.Object3D  ) {
						if(child.name== valueName){
							child.visible = value;
						}
					}
				});
				render();
			}
			
			
			function loadModel( fileName ) {

				const loader = new THREE.BufferGeometryLoader();
				loader.load( '/EGS_Collab_AR/BufferGeometry/' + fileName, function ( geometry ) {

					geometry.computeVertexNormals();

					const object = new THREE.Mesh( geometry, materialModel );
					
					loadedModel.add( object );

				} );

			}
			
			function loadCSV(){
				const csvloader = new THREE.FileLoader();
				csvloader.load('/EGS_Collab_AR/csvData/Old_wellhead_coords.csv',
					function(data){
						csvData = csvParse(data);
						for(let i = 0; i < csvData.length; i++){
							if (csvData[i].WellID == params.textField){
								baseNorthing = -2779.125 - parseFloat(csvData[i].Northing_ft);
								baseEasting = 4047.435 + parseFloat(csvData[i].Easting_ft);
								baseElev = -1047.088 + parseFloat(csvData[i].Elevation_ft);
							}
						}
						
						const dataCsvloader = new THREE.FileLoader();
						dataCsvloader.load('/EGS_Collab_AR/csvData/cs_' + params.textField + '.csv',
							function ( data ) {
								csvData = csvParse(data);
								let v3array = [];
								for(let i = 1; i < csvData.length; i++){
									if(parseFloat(csvData[i].Depth) >= parseFloat(csvData[i-1].Depth)){
										let xpos = (parseFloat(csvData[i-1].Easting) * 3.28084) - baseEasting;
										let ypos = (parseFloat(csvData[i-1].Elev) * 3.28084) + baseElev;
										let zpos = (-parseFloat(csvData[i-1].Northing) * 3.28084) + baseNorthing;
										v3array.push(new THREE.Vector3(xpos, ypos, zpos));
									}
								}
								boreholeSpline = new THREE.CatmullRomCurve3(v3array);
								addTube(boreholeSpline);
							}
						);
					}
				);
				
				
			}
			
			function addTube(inputtube) {

				if ( meshSpline !== undefined ) {

					scene.remove( meshSpline );
					meshSpline.geometry.dispose();

				}

				const extrudePath = inputtube;

				tubeGeometry = new THREE.TubeGeometry( extrudePath, 100, 0.5, 8, false );
				addGeometry( tubeGeometry );
			}
			
			function addGeometry( geometry ) {

				// 3D shape
				// default color attribute
				const colors = [];
				for ( let i = 0, n = geometry.attributes.position.count; i < n; ++ i ) {
					colors.push( 1, 1, 1 );
				}
				
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				
				meshSpline = new THREE.Mesh( geometry, material );
				updateColors();

				loadedModel.add( meshSpline );

			}
			
			function updateColors() {

				lut.setColorMap( 'blackbody' );

				lut.setMax( 100 );
				lut.setMin( -100 );

				const geometry = meshSpline.geometry;
				const pressures = geometry.attributes.position;  //this is the data value for each vertex
				const colors = geometry.attributes.color;
				let depth = [];
				let v3array = [];

				for ( let i = 0; i < pressures.array.length/3; i ++ ) {
					let new_v3array = [];
					new_v3array = new THREE.Vector3(pressures.array[ i * 3 ], pressures.array[ (i * 3) + 1], pressures.array[ (i * 3)  + 2]);
					
					if(i>0 && i%9 === 0){
						const dist = new_v3array.distanceTo(v3array);
						//console.log(dist);
						//depth.push(dist, dist, dist, dist, dist, dist, dist, dist, dist);
						v3array = new_v3array;
					}else{
					    //console.log(0)
						depth.push(0, 0, 0 ,0 ,0 ,0, 0, 0, 0);
						v3array = new_v3array;
					}
					
					const colorValue = pressures.array[ i * 3 ];

					const color = lut.getColor( colorValue );

					if ( color === undefined ) {

						console.log( 'Unable to determine color for value:', colorValue );

					} else {

						colors.setXYZ( i, color.r, color.g, color.b );

					}

				}
				console.log(depth);
				colors.needsUpdate = true;

				//const map = sprite.material.map;
				//lut.updateCanvas( map.image );
				//map.needsUpdate = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				labelRenderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}
			
			
			//

			function animate() {
				renderer.setAnimationLoop( render );
			}

			function render( timestamp, frame ) {

				raycaster.setFromCamera( pointer, camera );
				if (typeof meshSpline !== 'undefined') {
					const intersects = raycaster.intersectObject( meshSpline );
			
					if ( intersects.length > 0 ) {

						sphereInter.visible = true;
						sphereInter.position.copy( loadedModel.worldToLocal(intersects[ 0 ].point) );
						sphereInter.material.color = lut.getColor( sphereInter.position.x );
						valueLabel.visible = true;
						labelDiv.textContent = -sphereInter.position.x - 4047.435;

					} else {

						sphereInter.visible = false;
						valueLabel.visible = false;
					}
				}


				if ( frame ) {

					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if ( hitTestSourceRequested === false ) {

						session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {

							session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {

								hitTestSource = source;

							} );

						} );

						session.addEventListener( 'end', function () {

							hitTestSourceRequested = false;
							hitTestSource = null;

						} );

						hitTestSourceRequested = true;

					}

					if ( hitTestSource ) {

						const hitTestResults = frame.getHitTestResults( hitTestSource );

						if ( hitTestResults.length ) {

							const hit = hitTestResults[ 0 ];

							reticle.visible = true;
							reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );

						} else {

							reticle.visible = false;

						}

					}

				}

				renderer.render( scene, camera );
				labelRenderer.render( scene, camera );

			}

		</script>
	</body>
</html>