<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EGS Collab AR</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">EGS Collab</a> AR <br/>
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { ARButton } from './jsm/webxr/ARButton.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './jsm/environments/RoomEnvironment.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import {csvParse} from "https://cdn.skypack.dev/d3-dsv@3";
			import { Lut } from './jsm/math/Lut.js';

			let container;
			let camera, scene, renderer, loadedModel;
			let controller, lut;
			let meshSpline;

			let reticle;
			
			let csvData;
			let baseNorthing, baseEasting, baseElev;

			let hitTestSource = null;
			let hitTestSourceRequested = false;
			
			let boreholeSpline, tubeGeometry;
			const material = new THREE.MeshLambertMaterial( {
					side: THREE.DoubleSide,
					color: 0xF5F5F5,
					vertexColors: true} );
			const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.3, wireframe: true, transparent: true } );

			const params = {
				toggleTunnel: true,
				toggleGrid: false,
                toggleBoreholes: true,
                toggleElectrodes: true,
                toggleGyroStartPoints: true,
                toggleGyroSrikeDipDepth: true,
                toggleGyroXYZ: true,
				textField: "E2-TC",
				loadCSV: loadCSV
				};

			init();
			animate();
			
			

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );
				
				lut = new Lut();
				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 50 );
				camera.position.set( 0, 7, 0 );
				
				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				
				scene = new THREE.Scene();
				loadedModel = new THREE.Group();
				//scene.background = new THREE.Color( 0xbbbbbb );
				//scene.environment = pmremGenerator.fromScene( environment ).texture;
				
				scene.background = null;
				scene.environment = null;
				
				const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
				light.position.set( 0.5, 1, 0.25 );
				scene.add( light );
				

				const grid = new THREE.GridHelper( 10, 100, 0xffffff, 0xffffff );
				grid.material.opacity = 0.5;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				grid.visible = false;
				scene.add( grid );
				
				const loader = new GLTFLoader().setPath( '/EGS_Collab_AR/GLTF/' );
				loader.load('EGS_Collab.gltf', function ( gltf ){
							console.log(gltf);
							loadedModel.add(gltf.scene);
							loadedModel.scale.set(0.01,0.01,0.01)
							scene.add(loadedModel);
							render();
						});
				
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.01;
				controls.maxDistance = 1000;
				controls.target.set( 0, 0, 0 );
				controls.update();

				document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

				function onSelect() {

					if ( reticle.visible ) {
						
						loadedModel.position.setFromMatrixPosition( reticle.matrix );
						loadedModel.scale.set(0.005,0.005,0.005);
						render();
					}
				}
				

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'select', onSelect );
				scene.add( controller );

				reticle = new THREE.Mesh(
					new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial()
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add( reticle );


				window.addEventListener( 'resize', onWindowResize );
				
				loadModel();
				
				
				//
				
				const gui = new GUI();
				const baseFolder = gui.addFolder( 'Base Objects' );
				baseFolder.add(params, 'toggleTunnel').name('Tunnel').onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Group  ) {
							if(child.name=='TunnelOnly'){
								child.visible = value;
							}
						}
					});
					render();
				});
				baseFolder.add(params, 'toggleGrid').name('Grid').onChange( function (value){
					grid.visible = value;
					render();
				});
				const planningFolder = gui.addFolder( 'Planned Positions' );
				planningFolder.add(params, 'toggleBoreholes').name('Boreholes').onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh  ) {
							if(child.name=='BoreholesOnly'){
								child.visible = value;
							}
						}
					});
					render();
				});
				planningFolder.add(params, 'toggleElectrodes').name('Electrodes').onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Electrodes'){
								child.visible = value;
							}
						}
					});
					render();
				});
				const gyroFolder = gui.addFolder( 'Gyro Data' );
                gyroFolder.add(params, 'toggleGyroStartPoints' ).name( 'Start Points' ).onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Gyro_StartingPoints'){
								child.visible = value;
							}
						}
					});
					render();
				});
                gyroFolder.add(params, 'toggleGyroSrikeDipDepth' ).name( 'Strike/Dip/Depth Points' ).onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Gyro_XYZPoints'){
								child.visible = value;
							}
						}
					});
					render();
				});
                gyroFolder.add(params, 'toggleGyroXYZ' ).name( 'XYZ Points' ).onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Gyro_StrikeDipDepthPoints'){
								child.visible = value;
							}
						}
					});
					render();
				});
				const importFolder = gui.addFolder( 'Import Gyro Data' );
				importFolder.add(params, "textField").name('File Name');
				importFolder.add(params, "loadCSV").name('Load CSV');
				
				
			}
			
			function loadModel( ) {

				const loader = new THREE.BufferGeometryLoader();
				loader.load( '/EGS_Collab_AR/BufferGeometry/SampleBufferGeometry.json', function ( geometry ) {

					geometry.center();
					geometry.computeVertexNormals();

					const object = new THREE.Mesh( geometry, material );
					console.log(object);
					
					loadedModel.add( object );

				} );

			}
			
			function loadCSV(){
				const csvloader = new THREE.FileLoader();
				csvloader.load('/EGS_Collab_AR/csvData/Old_wellhead_coords.csv',
					function(data){
						csvData = csvParse(data);
						for(let i = 0; i < csvData.length; i++){
							if (csvData[i].WellID == params.textField){
								baseNorthing = -2779.125 - parseFloat(csvData[i].Northing_ft);
								baseEasting = 4047.435 + parseFloat(csvData[i].Easting_ft);
								baseElev = -1047.088 + parseFloat(csvData[i].Elevation_ft);
							}
						}
						
						const dataCsvloader = new THREE.FileLoader();
						dataCsvloader.load('/EGS_Collab_AR/csvData/cs_' + params.textField + '.csv',
							function ( data ) {
								csvData = csvParse(data);
								let v3array = [];
								for(let i = 0; i < csvData.length; i++){
									let xpos = (parseFloat(csvData[i].Easting) * 3.28084) - baseEasting;
									let ypos = (parseFloat(csvData[i].Elev) * 3.28084) + baseElev;
									let zpos = (-parseFloat(csvData[i].Northing) * 3.28084) + baseNorthing;
									v3array.push(new THREE.Vector3(xpos, ypos, zpos));
								}
								boreholeSpline = new THREE.CatmullRomCurve3(v3array);
								addTube(boreholeSpline);
							}
						);
					}
				);
				
				
			}
			
			function addTube(inputtube) {

				if ( meshSpline !== undefined ) {

					scene.remove( meshSpline );
					meshSpline.geometry.dispose();

				}

				const extrudePath = inputtube;

				tubeGeometry = new THREE.TubeGeometry( extrudePath, 100, 0.5, 8, false );

				addGeometry( tubeGeometry );
			}
			
			function addGeometry( geometry ) {

				// 3D shape
				// default color attribute
				const colors = [];
				for ( let i = 0, n = geometry.attributes.position.count; i < n; ++ i ) {
					colors.push( 1, 1, 1 );
				}
				
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				
				meshSpline = new THREE.Mesh( geometry, material );
				
				updateColors();

				loadedModel.add( meshSpline );

			}
			
			function updateColors() {

				lut.setColorMap( 'blackbody' );

				lut.setMax( 100 );
				lut.setMin( -100 );

				const geometry = meshSpline.geometry;
				const pressures = geometry.attributes.position;  //this is the data value for each vertex
				const colors = geometry.attributes.color;

				for ( let i = 0; i < pressures.array.length/3; i ++ ) {

					const colorValue = pressures.array[ i * 3 ];

					const color = lut.getColor( colorValue );

					if ( color === undefined ) {

						console.log( 'Unable to determine color for value:', colorValue );

					} else {

						colors.setXYZ( i, color.r, color.g, color.b );

					}

				}

				colors.needsUpdate = true;

				//const map = sprite.material.map;
				//lut.updateCanvas( map.image );
				//map.needsUpdate = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {
				renderer.setAnimationLoop( render );
			}

			function render( timestamp, frame ) {

				if ( frame ) {

					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if ( hitTestSourceRequested === false ) {

						session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {

							session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {

								hitTestSource = source;

							} );

						} );

						session.addEventListener( 'end', function () {

							hitTestSourceRequested = false;
							hitTestSource = null;

						} );

						hitTestSourceRequested = true;

					}

					if ( hitTestSource ) {

						const hitTestResults = frame.getHitTestResults( hitTestSource );

						if ( hitTestResults.length ) {

							const hit = hitTestResults[ 0 ];

							reticle.visible = true;
							reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );

						} else {

							reticle.visible = false;

						}

					}

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>