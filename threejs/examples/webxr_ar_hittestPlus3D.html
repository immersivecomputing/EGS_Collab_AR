<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EGS Collab AR</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">EGS Collab</a> AR <br/>
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { ARButton } from './jsm/webxr/ARButton.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './jsm/environments/RoomEnvironment.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import {csvParse} from "https://cdn.skypack.dev/d3-dsv@3";

			let container;
			let camera, scene, renderer, loadedModel;
			let controller;
			let meshSpline;

			let reticle;
			
			let csvData;

			let hitTestSource = null;
			let hitTestSourceRequested = false;
			
			let boreholeSpline, tubeGeometry;
			const material = new THREE.MeshLambertMaterial( { color: 0xff00ff } );
			const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.3, wireframe: true, transparent: true } );

			const params = {
				toggleTunnel: true,
				toggleGrid: false,
                toggleBoreholes: true,
                toggleElectrodes: true,
                toggleGyroStartPoints: true,
                toggleGyroSrikeDipDepth: true,
                toggleGyroXYZ: true
				};

			init();
			animate();
			
			

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );
				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 50 );
				camera.position.set( 0, 7, 0 );
				
				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				
				scene = new THREE.Scene();
				loadedModel = new THREE.Group();
				//scene.background = new THREE.Color( 0xbbbbbb );
				//scene.environment = pmremGenerator.fromScene( environment ).texture;
				
				scene.background = null;
				scene.environment = null;
				
				const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
				light.position.set( 0.5, 1, 0.25 );
				scene.add( light );
				

				const grid = new THREE.GridHelper( 10, 100, 0xffffff, 0xffffff );
				grid.material.opacity = 0.5;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				grid.visible = false;
				scene.add( grid );
				
				const loader = new GLTFLoader().setPath( '/EGS_Collab_AR/GLTF/' );
				loader.load('EGS_Collab.gltf', function ( gltf ){
							console.log(gltf);
							//gltf.scene.position.y = 8;
							gltf.scene.scale.set(0.01,0.01,0.01) // scale here
							loadedModel = gltf.scene;
							scene.add(gltf.scene);
							render();
						});
				
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.01;
				controls.maxDistance = 1000;
				controls.target.set( 0, 0, 0 );
				controls.update();

				document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

				function onSelect() {

					if ( reticle.visible ) {
						
						loadedModel.position.setFromMatrixPosition( reticle.matrix );
						loadedModel.scale.set(0.005,0.005,0.005);
						render();
					}
				}
				

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'select', onSelect );
				scene.add( controller );

				reticle = new THREE.Mesh(
					new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial()
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add( reticle );


				window.addEventListener( 'resize', onWindowResize );
				
				
				//
				
				const gui = new GUI();
				const baseFolder = gui.addFolder( 'Base Objects' );
				baseFolder.add(params, 'toggleTunnel').name('Tunnel').onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Group  ) {
							if(child.name=='TunnelOnly'){
								child.visible = value;
							}
						}
					});
					render();
				});
				baseFolder.add(params, 'toggleGrid').name('Grid').onChange( function (value){
					grid.visible = value;
					render();
				});
				const planningFolder = gui.addFolder( 'Planned Positions' );
				planningFolder.add(params, 'toggleBoreholes').name('Boreholes').onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh  ) {
							if(child.name=='BoreholesOnly'){
								child.visible = value;
							}
						}
					});
					render();
				});
				planningFolder.add(params, 'toggleElectrodes').name('Electrodes').onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Electrodes'){
								child.visible = value;
							}
						}
					});
					render();
				});
				const gyroFolder = gui.addFolder( 'Gyro Data' );
                gyroFolder.add(params, 'toggleGyroStartPoints' ).name( 'Start Points' ).onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Gyro_StartingPoints'){
								child.visible = value;
							}
						}
					});
					render();
				});
                gyroFolder.add(params, 'toggleGyroSrikeDipDepth' ).name( 'Strike/Dip/Depth Points' ).onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Gyro_StrikeDipDepthPoints'){
								child.visible = value;
							}
						}
					});
					render();
				});
                gyroFolder.add(params, 'toggleGyroXYZ' ).name( 'XYZ Points' ).onChange( function (value){
					loadedModel.traverse( function ( child ) {
						if ( child instanceof THREE.Object3D  ) {
							if(child.name=='Gyro_XYZPoints'){
								child.visible = value;
							}
						}
					});
					render();
				});
				
				//
				
				const csvloader = new THREE.FileLoader();
				csvloader.load(
					// resource URL
					'/EGS_Collab_AR/csvData/cs_E2-TC.csv',

					// onLoad callback
					function ( data ) {
						csvData = csvParse(data);
						let v3array = [];
						for(let i = 1; i < csvData.length; i++){
							v3array.push(new THREE.Vector3(csvData[i].Easting, csvData[i].Northing, csvData[i].Elev));
						}
						//boreholeSpline = new THREE.CatmullRomCurve3(v3array);
						boreholeSpline = new THREE.CatmullRomCurve3( [
				new THREE.Vector3( 0, 10, - 10 ), new THREE.Vector3( 10, 0, - 10 ),
				new THREE.Vector3( 20, 0, 0 ), new THREE.Vector3( 30, 0, 10 ),
				new THREE.Vector3( 47.263, 0, 20.259 ), new THREE.Vector3( 20, 0, 30 ),
				new THREE.Vector3( 10, 0, 30 ), new THREE.Vector3( 0, 0, 30 ),
				new THREE.Vector3( - 10, 10, 30 ), new THREE.Vector3( - 10, 20, 30 ),
				new THREE.Vector3( 0, 30, 30 ), new THREE.Vector3( 10, 30, 30 ),
				new THREE.Vector3( 20, 30, 15 ), new THREE.Vector3( 10, 30, 10 ),
				new THREE.Vector3( 0, 30, 10 ), new THREE.Vector3( - 10, 20, 10 ),
				new THREE.Vector3( - 10, 10, 10 ), new THREE.Vector3( 0, 0, 10 ),
				new THREE.Vector3( 10, - 10, 10 ), new THREE.Vector3( 20, - 15, 10 ),
				new THREE.Vector3( 30, - 15, 10 ), new THREE.Vector3( 40, - 15, 10 ),
				new THREE.Vector3( 50, - 15, 10 ), new THREE.Vector3( 60, 0, 10 ),
				new THREE.Vector3( 70, 0, 0 ), new THREE.Vector3( 80, 0, 0 ),
				new THREE.Vector3( 90, 0, 0 ), new THREE.Vector3( 100, 0, 0 )
			] );
						
						console.log(boreholeSpline);
						addTube(boreholeSpline);
					}
				);
			}
			
			function addTube(inputtube) {

				if ( meshSpline !== undefined ) {

					scene.remove( meshSpline );
					meshSpline.geometry.dispose();

				}

				const extrudePath = inputtube;

				tubeGeometry = new THREE.TubeGeometry( extrudePath, 100, 2, 8, true );

				addGeometry( tubeGeometry );
			}
			
			function addGeometry( geometry ) {

				// 3D shape

				meshSpline = new THREE.Mesh( geometry, material );
				const wireframe = new THREE.Mesh( geometry, wireframeMaterial );
				meshSpline.add( wireframe );

				scene.add( meshSpline );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {
				renderer.setAnimationLoop( render );
			}

			function render( timestamp, frame ) {

				if ( frame ) {

					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if ( hitTestSourceRequested === false ) {

						session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {

							session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {

								hitTestSource = source;

							} );

						} );

						session.addEventListener( 'end', function () {

							hitTestSourceRequested = false;
							hitTestSource = null;

						} );

						hitTestSourceRequested = true;

					}

					if ( hitTestSource ) {

						const hitTestResults = frame.getHitTestResults( hitTestSource );

						if ( hitTestResults.length ) {

							const hit = hitTestResults[ 0 ];

							reticle.visible = true;
							reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );

						} else {

							reticle.visible = false;

						}

					}

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>