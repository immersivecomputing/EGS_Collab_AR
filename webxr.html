<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Realtime ERT</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="./threejs/examples/main.css">
		<style>
		.label {
			color: #FFF;
			font-family: sans-serif;
			padding: 2px;
			background: rgba( 0, 0, 0, .6 );
		}

		input[type=range] {
			-webkit-appearance: none;
			margin: 20px 0;
			width: 100%;
		}
		input[type=range]:focus {
			outline: none;
		}
		input[type=range]::-webkit-slider-runnable-track {
			width: 100%;
			height: 4px;
			cursor: pointer;
			animate: 0.2s;
			background: #03a9f4;
			border-radius: 25px;
		}
		input[type=range]::-webkit-slider-thumb {
			height: 20px;
			width: 20px;
			border-radius: 50%;
			background: #fff;
			box-shadow: 0 0 4px 0 rgba(0,0,0, 1);
			cursor: pointer;
			-webkit-appearance: none;
			margin-top: -8px;
		}
		input[type=range]:focus::-webkit-slider-runnable-track {
			background: #03a9f4;
		}
		.range-wrap{
			width: 50%;
			position: absolute;
			margin-left: 25%;
			margin-right: auto;
			bottom: 100px;
		}
		.range-value{
			position: absolute;
			top: -50%;
		}
		.range-value span{
			width: 150px;
			height: 24px;
			line-height: 24px;
			text-align: center;
			background: #03a9f4;
			color: #fff;
			font-size: 12px;
			display: block;
			position: absolute;
			left: 50%;
			transform: translate(-50%, 0);
			border-radius: 6px;
		}
		.range-value span:before{
			content: "";
			position: absolute;
			width: 0;
			height: 0;
			border-top: 10px solid #03a9f4;
			border-left: 5px solid transparent;
			border-right: 5px solid transparent;
			top: 100%;
			left: 50%;
			margin-left: -5px;
			margin-top: -1px;
		}



		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://immersivecomputing.github.io/EGS_Collab_AR/" target="_blank" rel="noopener">RealTime ERT</a> AR <br/>
		</div>
		<script type="module">


			let pathPrefix = './';
			//let pathPrefix = './main/';

			async () => {
				const { THREE } = await import(pathPrefix + 'threejs/build/three.module.js');
				const { ARButton } = await import(pathPrefix + 'threejs/examples/jsm/webxr/ARButton.js');
				const { OrbitControls } = await import(pathPrefix + 'threejs/examples/jsm/controls/OrbitControls.js');
				const { RoomEnvironment } = await import(pathPrefix + 'threejs/examples/jsm/environments/RoomEnvironment.js');
				const { Lut } = await import(pathPrefix + 'threejs/examples/jsm/math/Lut.js');
				const { FontLoader } = await import(pathPrefix + 'threejs/examples/jsm/loaders/FontLoader.js');
				const { LoadOBJ } = await import(pathPrefix + 'LoadSurfaces.js');
				const { LoadVTK } = await import(pathPrefix + 'LoadSurfaces.js');
			}



			// import * as THREE from pathPrefix + 'threejs/build/three.module.js';
			// import { ARButton } from pathPrefix + 'threejs/examples/jsm/webxr/ARButton.js';
			// import { OrbitControls } from pathPrefix + 'threejs/examples/jsm/controls/OrbitControls.js';
			// import { RoomEnvironment } from pathPrefix + 'threejs/examples/jsm/environments/RoomEnvironment.js';
			// import { Lut } from pathPrefix + 'threejs/examples/jsm/math/Lut.js';
			// import { FontLoader } from pathPrefix + 'threejs/examples/jsm/loaders/FontLoader.js';
			// import { LoadOBJ } from pathPrefix + 'LoadSurfaces.js';
			// import { LoadVTK } from pathPrefix + 'LoadSurfaces.js';
			import { Octokit, App } from "https://cdn.skypack.dev/octokit"; //This is the only dependancy for the GitHub api, can be removed when new endpoint made

			

			let container;
			let viewSize, originalAspect;
			let camera, scene, renderer, loadedModel, currentModelGroup, orthoCamera, uiScene, currentLoadedData, geometryOffsetX, geometryOffsetY;
			let currentFrame = 0;
			let controller, lut, sprite;
			const pointer = new THREE.Vector2();
			let reticle;
			let dataArray = [];
			let hitTestSource = null;
			let hitTestSourceRequested = false;

			const clipPlaneMaterial = new THREE.MeshBasicMaterial({
				color: 'rgb(100,100,100)',
				side: THREE.DoubleSide
			});

			let clipPlanes, clipPlaneObjects, clipPlaneHelpers, clipObject, clipPlaneGeom;
			const clipParams = {
				planeX: {
					constant: 0,
					negated: false,
					displayHelper: false
				},
				planeY: {
					constant: 0,
					negated: false,
					displayHelper: false
				},
				planeZ: {
					constant: 0,
					negated: false,
					displayHelper: false
				}
			};

			FetchData();
			
			//First fetch all the data
			//This is currently coming in from a GitHub Repo so will need to be changed to the correct endpoint, the object indexing may also need to be changed 

			async function FetchData(){
				const octokit = new Octokit();

				let data = await octokit.request('GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=true', {
					owner: 'immersivecomputing',
					repo: 'EGS_Collab_AR',
					tree_sha: '5044df10a275d5303e190ab1df0cc28ddd6fd5f2'
				});
				

				console.log(data);
				var counter = 0;
				for(let i=0; i < data.data.tree.length; i++){

					if (data.data.tree[i].type == "tree"){
						dataArray.push(data.data.tree[i]);
						dataArray[counter].vtkFiles = [];
						counter++;
					}else if(data.data.tree[i].type == "blob" && data.data.tree[i].path.includes("vtk")){
						dataArray[counter-1].vtkFiles.push(data.data.tree[i].path);
					}
				}
				console.log(dataArray);

				//Start loading using ThreeJS
				init();
				animate();
			}
			

			function init() {

				
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				renderer.localClippingEnabled = true;
				renderer.autoClear = false;
				container.appendChild( renderer.domElement );
							
				lut = new Lut();
				
				scene = new THREE.Scene();
				
				uiScene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 500 );
				camera.position.set( 0, 100, 0 );
				scene.add(camera);

				viewSize = 2;
				var aspectRatio = window.innerWidth / window.innerHeight;
				originalAspect = window.innerWidth / window.innerHeight;
    			orthoCamera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, 1, 20);
				orthoCamera.position.set( 0.95, 0.5, 10 );
				
				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				

				sprite = new THREE.Sprite( new THREE.SpriteMaterial( {
					map: new THREE.CanvasTexture( lut.createCanvas() )
				} ) );
				sprite.scale.x = 0.0625;
				sprite.scale.y = 0.5;
				uiScene.add( sprite );
				createAxisText(0.05,-0.25,0,0,0,0,'cmin', 'cmin', sprite);
				createAxisText(0.05,0.25,0,0,0,0,'cmax', 'cmax', sprite);
				createAxisText(-0.1,-0.05,0,0,0,90,'title','Bulk Conductivity', sprite);

				loadedModel = new THREE.Group();
				currentModelGroup = new THREE.Group();
				loadedModel.add(currentModelGroup);
				
				scene.background = null;
				scene.environment = null;
				
				const light = new THREE.HemisphereLight( 0xffffff, 0x080808, 1.5 );
				light.position.set( -1.25, 1, 1.25 );
				scene.add( light );
				

				const grid = new THREE.GridHelper( 100, 10, 0xffffff, 0xffffff );
				grid.material.opacity = 0.5;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				grid.visible = true;
				scene.add( grid );

				//clip planes
				clipPlaneObjects = [];
				clipObject = new THREE.Group();
				clipObject.rotation.x = -Math.PI / 2;
				scene.add(clipObject);
				clipPlaneGeom = [
					new THREE.PlaneGeometry(100, 100),
					new THREE.PlaneGeometry(100, 100),
					new THREE.PlaneGeometry(100, 100)
				];
				clipPlanes = [
					new THREE.Plane(new THREE.Vector3(1, 0, 0), 0),
					new THREE.Plane(new THREE.Vector3(0, -1, 0), 0),
					new THREE.Plane(new THREE.Vector3(0, 0, -1), 0)
				];
				clipPlaneHelpers = [
					new THREE.Mesh(clipPlaneGeom[0], clipPlaneMaterial),
					new THREE.Mesh(clipPlaneGeom[1], clipPlaneMaterial),
					new THREE.Mesh(clipPlaneGeom[2], clipPlaneMaterial)
				];
				clipPlaneHelpers[0].rotation.y = Math.PI / 2;
				clipPlaneHelpers[1].rotation.x = Math.PI / 2;

				
				//Load ERT Location data
				LoadERTSensorLocation(loadedModel);

				lut.setColorMap('rainbow');
				lut.setMin(0);
				
				//plot first time step
				LoadVTKTimeStep(0);

				//Handle axis changes from Visit:
				loadedModel.rotation.set((Math.PI/180) * -90,0,0);
				scene.add(loadedModel);

				//XR Section
				document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

				function onSelect() {

					if ( reticle.visible ) {
						
						loadedModel.position.setFromMatrixPosition( reticle.matrix );
						loadedModel.position.set(loadModel.position.x, loadedModel.position.y, loadedModel.position.z + 0.01);
						loadedModel.scale.set(0.0005,0.0005,0.0005);
						render();
					}
				}
				

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'select', onSelect );
				scene.add( controller );

				reticle = new THREE.Mesh(
					new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial()
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add( reticle );
				//end XR Section

				window.addEventListener( 'resize', onWindowResize );

				//add orbit controls first
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.01;
				controls.maxDistance = 1000;
				controls.target.set( 0, 0, 0 );
				controls.update();

				//Then add an overlay slider
				var slider = document.getElementById("range");
				slider.step = 1/(dataArray.length-1);
				slider.addEventListener("input", loadTimeFrame);

				console.log(scene);
			}

			function loadTimeFrame(e)
			{
				var target = (e.target) ? e.target : e.srcElement;
				var scaledTargetValue = parseInt(target.value * (dataArray.length-1)); 
				var rangeV = document.getElementById('rangeV');

				var newValue = Number( (target.value - target.min) * 100 / (target.max - target.min) );
      			var newPosition = 10 - (newValue * 0.2);
				rangeV.innerHTML = `<span>${dataArray[scaledTargetValue].path}</span>`;
    			rangeV.style.left = `calc(${newValue}% + (${newPosition}px))`;	

				if (scaledTargetValue != currentFrame){
					currentFrame = scaledTargetValue;
					LoadVTKTimeStep(currentFrame);
				}
			}

			function LoadVTKTimeStep(timeStepInt){
				
				for( var i = currentModelGroup.children.length - 1; i >= 0; i--) { 
     				var obj = currentModelGroup.children[i];
					obj.geometry.dispose();
					obj.material.dispose();
     				currentModelGroup.remove(obj); 
				}

				lut.setMax(dataArray[timeStepInt].vtkFiles.length-1);
				//These are dummy values for now
				updateAxisText('cmin', 1);
				updateAxisText('cmax', dataArray[timeStepInt].vtkFiles.length);

				for(let i=0; i < dataArray[timeStepInt].vtkFiles.length; i++){
					LoadVTK(currentModelGroup, dataArray[timeStepInt].vtkFiles[i], dataArray[0].vtkFiles.length - (i + 1), lut.getColor(i), clipPlanes);	
				}
			}

			function LoadERTSensorLocation(loadedModel){
				
				const material = new THREE.MeshBasicMaterial( {color: 0xdba91f} );
				const geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );

				var sumEastings = 0;
				var sumNorthings = 0;

				const dataTextloader = new THREE.FileLoader();
				dataTextloader.load(pathPrefix + 'EGS_Collab_AR/ERT_Data/electrodes.txt',
					function ( data ) {
						var lines = data.split('\n');
						lines.map(function(item){
      						var tabs = item.split('\t');
							
							if(typeof tabs[1] !== 'undefined'){
								const cube = new THREE.Mesh( geometry, material );
								cube.position.set(tabs[1], tabs[2], tabs[3]);
							    loadedModel.add( cube );
							
								sumEastings = sumEastings + parseFloat(tabs[1]);
								sumNorthings = sumNorthings + parseFloat(tabs[2]);
							}
						});
						
						geometryOffsetX = sumEastings / (lines.length-1);
						geometryOffsetY = sumNorthings / (lines.length-1);

						loadedModel.position.set(-geometryOffsetX, 0, geometryOffsetY); 		
					}
				);	
			}
			
			function createAxisText(x,y,z,rx,ry,rz, axisName, label, _sprite) {

				const loader = new FontLoader();
				loader.load(pathPrefix + 'threejs/examples/fonts/helvetiker_regular.typeface.json', function (response) {

					var font = response;

					var textGeo = new THREE.TextGeometry(label, {
						size: 0.025,
						height: 0.001,
						curveSegments: 6,
						font: font
					});

					var color = new THREE.Color();
					color.setRGB(255, 250, 250);
					var textMaterial = new THREE.MeshBasicMaterial({ color: color });
					var axisLabel = new THREE.Mesh(textGeo, textMaterial);

					axisLabel.position.x = x;
					axisLabel.position.y = y;
					axisLabel.position.z = -0.05;
					axisLabel.rotation.x = rx * (Math.PI / 180);
					axisLabel.rotation.y = ry * (Math.PI / 180);
					axisLabel.rotation.z = rz * (Math.PI / 180);
					axisLabel.name = axisName;

					_sprite.attach(axisLabel);
				});
			}

			function updateAxisText(axisName, newText){
				const loader = new FontLoader();
				loader.load(pathPrefix + 'threejs/examples/fonts/helvetiker_regular.typeface.json', function (response) {
					var font = response;

					if (typeof newText == 'string'){
						var textGeo = new THREE.TextGeometry(newText, {
							size: 0.025,
							height: 0.001,
							curveSegments: 6,
							font: font
						});
					}else{
						var textGeo = new THREE.TextGeometry(newText.toFixed(2), {
							size: 0.025,
							height: 0.001,
							curveSegments: 6,
							font: font
						});
					}

					let labelObject = sprite.getObjectByName(axisName);
					labelObject.geometry = textGeo;
				});
			}

			function onWindowResize() {
				
				var aspect = window.innerWidth / window.innerHeight;
				var change = originalAspect / aspect;
				var newSize = viewSize * change;
				orthoCamera.left = -aspect * newSize / 2;
				orthoCamera.right = aspect * newSize  / 2;
				orthoCamera.top = newSize / 2;
				orthoCamera.bottom = -newSize / 2;
				orthoCamera.updateProjectionMatrix();

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}
			
			//Run the animation frames
			function animate() {
				renderer.setAnimationLoop( render );
			}

			function render( timestamp, frame ) {
				//Handle any XR session needs
				if ( frame ) {

					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if ( hitTestSourceRequested === false ) {
						session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
							session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {
								hitTestSource = source;
							} );
						} );

						session.addEventListener( 'end', function () {
							hitTestSourceRequested = false;
							hitTestSource = null;
						} );
						hitTestSourceRequested = true;
					}

					if ( hitTestSource ) {
						const hitTestResults = frame.getHitTestResults( hitTestSource );
						if ( hitTestResults.length ) {
							const hit = hitTestResults[ 0 ];
							reticle.visible = true;
							reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );
						} else {
							reticle.visible = false;
						}
					}
				}
				
				//Render the frame
				renderer.clear();
				renderer.render( scene, camera );
				renderer.render( uiScene, orthoCamera );
			}

		</script>


<div class="range-wrap">
    <div class="range-value" id="rangeV"></div>
    <input id="range" type="range" min="0" max="1" value="0" step="0.01">
  	</div>
	</body>
</html>