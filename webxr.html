<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EGS Collab AR</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="./threejs/examples/main.css">
		<style>
		.label {
				color: #FFF;
				font-family: sans-serif;
				padding: 2px;
				background: rgba( 0, 0, 0, .6 );
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://immersivecomputing.github.io/EGS_Collab_AR/" target="_blank" rel="noopener">RealTime ERT</a> AR <br/>
		</div>
		<script type="module">

			import * as THREE from './threejs/build/three.module.js';
			import { ARButton } from './threejs/examples/jsm/webxr/ARButton.js';
			import { GLTFLoader } from './threejs/examples/jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from './threejs/examples/jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './threejs/examples/jsm/environments/RoomEnvironment.js';
			import { GUI } from './threejs/examples/jsm/libs/dat.gui.module.js';
			//import {csvParse} from "https://cdn.skypack.dev/d3-dsv@3";
			import {csvParse} from "https://cdn.skypack.dev/-/d3-dsv@v3.0.1-u1xCRjaLJc0qqv1Z5ERe/dist=es2020,mode=imports/optimized/d3-dsv.js";
			import { Lut } from './threejs/examples/jsm/math/Lut.js';
			import { CSS2DRenderer, CSS2DObject } from './threejs/examples/jsm/renderers/CSS2DRenderer.js';
			import { Line2 } from './threejs/examples/jsm/lines/Line2.js';
			import { LineMaterial } from './threejs/examples/jsm/lines/LineMaterial.js';
			import { LineGeometry } from './threejs/examples/jsm/lines/LineGeometry.js';
			import { ControlPosition } from './threejs/examples/ControlPosition.js';
			import { FontLoader } from './threejs/examples/jsm/loaders/FontLoader.js';
			import { LoadOBJ } from './LoadSurfaces.js';
			import { LoadVTK } from './LoadSurfaces.js';
			import { ShowFeedbackText } from './FeedbackText.js';
			import { HideFeedbackText } from './FeedbackText.js';
			import { Octokit, App } from "https://cdn.skypack.dev/octokit";

			let container;
			let viewSize, originalAspect;
			let camera, scene, renderer, loadedModel, orthoCamera, uiScene, dataGroup, currentLoadedData, geometryOffsetX, geometryOffsetY;
			let objMaterial,objMaterial0,objMaterial1,objMaterial2,objMaterial3,objMaterial4,objMaterial5; 
			let controller, lut, lut2, rtTexture;
			let meshSpline, raycaster, sphereInter, sprite, sprite2, loadedLine, surfaceGroup;
			const pointer = new THREE.Vector2();
			
			let reticle;
			let planes;

			let dataArray = [];
			
			let mouseX = 0, mouseY = 0;

			let csvData, labelRenderer, labelDiv, valueLabel;
			
			let realtimeObject;

			let pmax = 8000;
			let pmin = 6000;
			let smax = 4000;
			let smin = 2000;
			let tmin = 20;
			let tmax = 30;
			let vpvsmin = 1.25;
			let vpvsmax = 2.5;

			let hitTestSource = null;
			let hitTestSourceRequested = false;
			let boreholesLoaded = false;
			
			let boreholeSpline, tubeGeometry;
			const material = new THREE.MeshLambertMaterial( {
					side: THREE.DoubleSide,
					color: 0xF5F5F5,
					vertexColors: true} );
			let materialModel;
					
			const windowHalfX = window.innerWidth / 2;
			const windowHalfY = window.innerHeight / 2;
			
			const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.3, wireframe: true, transparent: true } );


			FetchData();
			
			
			//First fetch all the data
			async function FetchData(){
				const octokit = new Octokit();

				let data = await octokit.request('GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=true', {
					owner: 'immersivecomputing',
					repo: 'EGS_Collab_AR',
					tree_sha: '5044df10a275d5303e190ab1df0cc28ddd6fd5f2'
				});
				
				var counter = 0;
				for(let i=0; i < data.data.tree.length; i++){

					if (data.data.tree[i].type == "tree"){
						dataArray.push(data.data.tree[i]);
						dataArray[counter].vtkFiles = [];
						counter++;
					}else if(data.data.tree[i].type == "blob" && data.data.tree[i].path.includes("vtk")){
						dataArray[counter-1].vtkFiles.push(data.data.tree[i].path);
					}
				}

				//Start loading using ThreeJS
				init();
				animate();

			}
			

			function init() {

				
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.xr.enabled = true;
				renderer.localClippingEnabled = true;
				renderer.autoClear = false;
				container.appendChild( renderer.domElement );

				rtTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat, type: THREE.FloatType } );
							
				lut = new Lut();
				
				scene = new THREE.Scene();
				
				uiScene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 500 );
				camera.position.set( 0, 100, 0 );
				scene.add(camera);

				//orthoCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 1, 20 );
				viewSize = 2;
				var aspectRatio = window.innerWidth / window.innerHeight;
				originalAspect = window.innerWidth / window.innerHeight;
    			orthoCamera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, 1, 20);
				orthoCamera.position.set( 0.95, 0.5, 10 );
				
				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				

				sprite = new THREE.Sprite( new THREE.SpriteMaterial( {
					map: new THREE.CanvasTexture( lut.createCanvas() )
				} ) );
				sprite.scale.x = 0.0625;
				sprite.scale.y = 0.5;
				uiScene.add( sprite );
				createAxisText(0.05,-0.25,0,0,0,0,'cmin', 'cmin', sprite);
				createAxisText(0.05,0.25,0,0,0,0,'cmax', 'cmax', sprite);
				createAxisText(-0.1,0,0,0,0,90,'title','title', sprite);
				sprite.visible = false;


				lut2 = new Lut();
				lut2.setColorMap('plasma');
				sprite2 = new THREE.Sprite( new THREE.SpriteMaterial( {
					map: new THREE.CanvasTexture( lut2.createCanvas() )
				} ) );
				sprite2.position.y = 1.0;
				sprite2.scale.x = 0.0625;
				sprite2.scale.y = 0.5;
				uiScene.add( sprite2 );
				createAxisText(0.05,-0.21875 + 1,0,0,0,0,'c0', '0', sprite2);
				createAxisText(0.05,-0.15625 + 1,0,0,0,0,'c1', '1', sprite2);
				createAxisText(0.05,-0.09375 + 1,0,0,0,0,'c2', '2', sprite2);
				createAxisText(0.05,-0.03125 + 1,0,0,0,0,'c3', '3', sprite2);
				createAxisText(0.05,0.03125 + 1,0,0,0,0,'c4', '4', sprite2);
				createAxisText(0.05,0.09375 + 1,0,0,0,0,'c5', '5', sprite2);
				createAxisText(0.05,0.15625 + 1,0,0,0,0,'c6', '6', sprite2);
				createAxisText(0.05,0.21875 + 1,0,0,0,0,'c7', '7', sprite2);
				createAxisText(-0.1,1,0,0,0,90,'surftitle','Bulk Conductivity', sprite2);
				sprite2.visible = false;


				loadedModel = new THREE.Group();
				//scene.background = new THREE.Color( 0xbbbbbb );
				//scene.environment = pmremGenerator.fromScene( environment ).texture;
				
				scene.background = null;
				scene.environment = null;
				
				const light = new THREE.HemisphereLight( 0xffffff, 0x080808, 1.5 );
				light.position.set( -1.25, 1, 1.25 );
				scene.add( light );
				

				const grid = new THREE.GridHelper( 100, 10, 0xffffff, 0xffffff );
				grid.material.opacity = 0.5;
				grid.material.depthWrite = false;
				grid.material.transparent = true;
				grid.visible = true;
				scene.add( grid );
				
				//Load ERT Location data
				LoadERTSensorLocation(loadedModel);

				lut.setColorMap('rainbow');
				lut.setMin(0);
				lut.setMax(dataArray[0].vtkFiles.length);
				
				for(let i=0; i < dataArray[0].vtkFiles.length; i++){
					LoadVTK(loadedModel, dataArray[0].vtkFiles[i], dataArray[0].vtkFiles.length - (i + 1), lut.getColor(i));	
				}

				//Handle axis changes from Visit:
				loadedModel.rotation.set((Math.PI/180) * -90,0,0);
				scene.add(loadedModel);

				//XR Section
				document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );

				function onSelect() {

					if ( reticle.visible ) {
						
						loadedModel.position.setFromMatrixPosition( reticle.matrix );
						loadedModel.position.set(loadModel.position.x, loadedModel.position.y, loadedModel.position.z + 0.01);
						loadedModel.scale.set(0.0005,0.0005,0.0005);
						render();
					}
				}
				

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'select', onSelect );
				scene.add( controller );

				reticle = new THREE.Mesh(
					new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial()
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add( reticle );
				//end XR Section



				window.addEventListener( 'resize', onWindowResize );
				
				// const gui = new GUI();
				// const baseFolder = gui.addFolder( 'Base Objects' );
				// baseFolder.add(params, 'toggleTunnel').name('Tunnel').onChange( function (value){
				// 	document.body.appendChild( HideFeedbackText());
				// 	ToggleValue(value,'TunnelOnly');
				// });
				// baseFolder.add(params, 'toggleBoreholesGyro').name('Boreholes').onChange( function (value){
				// 	document.body.appendChild( HideFeedbackText());
				// 	ToggleBoreholesGyro(value,'BoreholesGyro');
				// });
				// baseFolder.add(params, 'toggleGrid').name('Grid').onChange( function (value){
				// 	document.body.appendChild( HideFeedbackText());
				// 	grid.visible = value;
				// 	render();
				// });

				// const dataFolder = gui.addFolder('Logging');
				// dataFolder.add( params, 'showData').name('Show Log').onChange(function (value){					
				// 	ToggleData(value, params.dataType);
				// });
				// dataFolder.add( params, 'dataType', [ 'P Velocity', 'S Velocity', 'Vp/Vs', 'Temp.'] ).name('Log Type:').onChange(function (value){
				// 	ToggleData(params.showData, value);
				// });

				// const faultFolder = gui.addFolder('Faults');
				// faultFolder.add( params, 'showFaults').name('Show Faults').onChange(function(value){
				// 	ToggleFaults(value);
				// });
				// faultFolder.add( params, 'meanRatio', 0.02, 0.27).name('Mean Stress Ratio').onChange(function(value){
				// 	FilterFaults(value);
				// });
				// const surfaceFolder = gui.addFolder('Bulk Conductivity');
				// surfaceFolder.add(params, 'showSurfaces').name('Show Surfaces').onChange(function(value){
				// 	ToggleSurfaces(value);
				// });
				// surfaceFolder.add(params, 'surfaceNum', 0, 7).name('Conductivity g.t.').onChange(function (value) {
				// 	if(surfaceGroup != null){		
				// 		surfaceGroup.traverse(function (child){
				// 			if (parseInt(child.bulkConductivity) < value) {
				// 				child.visible = false;
				// 			} else {
				// 				child.visible = true;
				// 			}
				// 		});
				// 	}
				// });
				// surfaceFolder.add(params, 'surfaceOpacity', 0, 1).name('Opacity').onChange(function (value) {
				// 	if(surfaceGroup != null){	
				// 		surfaceGroup.traverse(function (child) {
				// 			if (child.isMesh) {
				// 				child.material.opacity = value;
				// 			}
				// 		});
				// 	}
				// });

				// const realtimeFolder = gui.addFolder('Realtime Data');
				// realtimeFolder.add(params, 'toggleRealtime').name('Device current position');


				//Tooltip option

				// const sphgeometry = new THREE.SphereGeometry( 2.5 );
				// const sphmaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
				// sphereInter = new THREE.Mesh( sphgeometry, sphmaterial );
				// sphereInter.visible = false;
				
				// loadedModel.add( sphereInter );
				// raycaster = new THREE.Raycaster();
				// document.addEventListener( 'pointermove', onPointerMove );
				
				// labelDiv = document.createElement( 'div' );
				// labelDiv.className = 'label';
				// labelDiv.textContent = '-';
				// labelDiv.style.marginTop = '-1em';
				// valueLabel = new CSS2DObject( labelDiv );
				// valueLabel.position.set( 0, 1, 0 );
				// valueLabel.visible = false;
				// sphereInter.add( valueLabel );
				
				labelRenderer = new CSS2DRenderer();
				labelRenderer.setSize( window.innerWidth, window.innerHeight );
				labelRenderer.domElement.style.position = 'absolute';
				labelRenderer.domElement.style.top = '0px';
				document.body.appendChild( labelRenderer.domElement );
				
				const controls = new OrbitControls( camera, labelRenderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 0.01;
				controls.maxDistance = 1000;
				controls.target.set( 0, 0, 0 );
				controls.update();

				document.addEventListener( 'mousemove', onDocumentMouseMove );

				console.log(scene);

			}


			function LoadERTSensorLocation(loadedModel){
				
				const material = new THREE.MeshBasicMaterial( {color: 0xdba91f} );
				const geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );

				var sumEastings = 0;
				var sumNorthings = 0;

				const dataTextloader = new THREE.FileLoader();
				dataTextloader.load('/EGS_Collab_AR/ERT_Data/electrodes.txt',
					function ( data ) {
						var lines = data.split('\n');
						lines.map(function(item){
      						var tabs = item.split('\t');
							
							if(typeof tabs[1] !== 'undefined'){
								const cube = new THREE.Mesh( geometry, material );
								cube.position.set(tabs[1], tabs[2], tabs[3]);
							    loadedModel.add( cube );
							
								sumEastings = sumEastings + parseFloat(tabs[1]);
								sumNorthings = sumNorthings + parseFloat(tabs[2]);
							}
						});

						
						geometryOffsetX = sumEastings / (lines.length-1);
						geometryOffsetY = sumNorthings / (lines.length-1);

						loadedModel.position.set(-geometryOffsetX, 0, geometryOffsetY); 
						
					}
				);
				
			}

			function onDocumentMouseMove( event ) {
				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );
			}

			
			function ToggleValue(value, valueName) {
				loadedModel.traverse( function ( child ) {
					if ( child instanceof THREE.Object3D  ) {
						if(child.name== valueName){
							child.visible = value;
						}
					}
				});
				render();
			}

			

			function ToggleSurfaces(value){

				document.body.appendChild( HideFeedbackText());

				let alreadyLoaded = false;
				loadedModel.traverse( function ( child ) {
					if(child.name == 'surfaces'){
						alreadyLoaded = true;
						child.visible = value;
						sprite2.visible = value;
					}
				});

				if (alreadyLoaded === false){	
					surfaceGroup = new THREE.Group();
					surfaceGroup.name = 'surfaces';
					loadedModel.add(surfaceGroup);
					//try loading a obj
					LoadOBJ('./objData/visit_ex_db_0000.obj', surfaceGroup, true, 7, 0x0d0887);
					LoadOBJ('./objData/visit_ex_db_0001.obj', surfaceGroup, true, 6, 0x5302a3);
					LoadOBJ('./objData/visit_ex_db_0002.obj', surfaceGroup, true, 5, 0x8b0aa5);
					LoadOBJ('./objData/visit_ex_db_0003.obj', surfaceGroup, true, 4, 0xb83289);
					LoadOBJ('./objData/visit_ex_db_0004.obj', surfaceGroup, true, 3, 0xdb5c68);
					LoadOBJ('./objData/visit_ex_db_0005.obj', surfaceGroup, true, 2, 0xf48849);
					LoadOBJ('./objData/visit_ex_db_0006.obj', surfaceGroup, true, 1, 0xfebd2a);
					LoadOBJ('./objData/visit_ex_db_0007.obj', surfaceGroup, true, 0, 0xF0F921);
					sprite2.visible = value;
				}
				
			}
			
			function createAxisText(x,y,z,rx,ry,rz, axisName, label, _sprite) {

				const loader = new FontLoader();
				loader.load('./threejs/examples/fonts/helvetiker_regular.typeface.json', function (response) {

					var font = response;

					var textGeo = new THREE.TextGeometry(label, {
						size: 0.025,
						height: 0.001,
						curveSegments: 6,
						font: font
					});

					var color = new THREE.Color();
					color.setRGB(255, 250, 250);
					var textMaterial = new THREE.MeshBasicMaterial({ color: color });
					var axisLabel = new THREE.Mesh(textGeo, textMaterial);

					axisLabel.position.x = x;
					axisLabel.position.y = y;
					axisLabel.position.z = -0.05;
					axisLabel.rotation.x = rx * (Math.PI / 180);
					axisLabel.rotation.y = ry * (Math.PI / 180);
					axisLabel.rotation.z = rz * (Math.PI / 180);
					axisLabel.name = axisName;

					_sprite.attach(axisLabel);
				});
			}

			function updateAxisText(axisName, newText){
				const loader = new FontLoader();
				loader.load('./threejs/examples/fonts/helvetiker_regular.typeface.json', function (response) {
					var font = response;

					if (typeof newText == 'string'){
						var textGeo = new THREE.TextGeometry(newText, {
							size: 0.025,
							height: 0.001,
							curveSegments: 6,
							font: font
						});
					}else{
						var textGeo = new THREE.TextGeometry(newText.toFixed(2), {
							size: 0.025,
							height: 0.001,
							curveSegments: 6,
							font: font
						});
					}

					let labelObject = sprite.getObjectByName(axisName);
					labelObject.geometry = textGeo;
				});
			}

			function onWindowResize() {
				
				var aspect = window.innerWidth / window.innerHeight;
				var change = originalAspect / aspect;
				var newSize = viewSize * change;
				orthoCamera.left = -aspect * newSize / 2;
				orthoCamera.right = aspect * newSize  / 2;
				orthoCamera.top = newSize / 2;
				orthoCamera.bottom = -newSize / 2;
				orthoCamera.updateProjectionMatrix();

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				labelRenderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function onPointerMove( event ) {

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}
			
			
			//

			function animate() {
				renderer.setAnimationLoop( render );
			}

			function render( timestamp, frame ) {

				// raycaster.setFromCamera( pointer, camera );
				// //if (typeof meshSpline !== 'undefined') {
				// //	const intersects = raycaster.intersectObject( meshSpline );
				// if (typeof loadedLine !== 'undefined') {
				//   	const intersects = raycaster.intersectObject( loadedLine );
			
				// 	if ( intersects.length > 0 ) {
						
				// 		const read = new Float32Array( 4 );
				// 		renderer.readRenderTargetPixels( rtTexture, windowHalfX + mouseX, windowHalfY - mouseY, 1, 1, read );
				// 		console.log(read);

				// 		sphereInter.visible = true;
				// 		sphereInter.position.copy( loadedModel.worldToLocal(intersects[ 0 ].point) );

				// 		sphereInter.material.color = lut.getColor( sphereInter.position.x );
				// 		valueLabel.visible = true;
				// 		labelDiv.textContent = -sphereInter.position.x - 4047.435;

				// 	} else {

				// 		sphereInter.visible = false;
				// 		valueLabel.visible = false;
				// 	}
				// }


				if ( frame ) {

					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if ( hitTestSourceRequested === false ) {

						session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {

							session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {

								hitTestSource = source;

							} );

						} );

						session.addEventListener( 'end', function () {

							hitTestSourceRequested = false;
							hitTestSource = null;

						} );

						hitTestSourceRequested = true;

					}

					if ( hitTestSource ) {

						const hitTestResults = frame.getHitTestResults( hitTestSource );

						if ( hitTestResults.length ) {

							const hit = hitTestResults[ 0 ];

							reticle.visible = true;
							reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );

						} else {

							reticle.visible = false;

						}

					}

				}
				

				
				renderer.clear();
				renderer.render( scene, camera );
				labelRenderer.render( scene, camera );
				renderer.render( uiScene, orthoCamera );

			}

		</script>
	</body>
</html>