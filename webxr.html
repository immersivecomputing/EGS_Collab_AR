<!DOCTYPE html>
<html lang="en">

<head>
	<title>Realtime ERT</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="./threejs/examples/main.css">
	<style>
		.label {
			color: #FFF;
			font-family: sans-serif;
			padding: 2px;
			background: rgba(0, 0, 0, .6);
		}

		input[type=range] {
			-webkit-appearance: none;
			margin: 20px 0;
			width: 100%;
		}

		input[type=range]:focus {
			outline: none;
		}

		input[type=range]::-webkit-slider-runnable-track {
			width: 100%;
			height: 4px;
			cursor: pointer;
			animate: 0.2s;
			background: #03a9f4;
			border-radius: 25px;
		}

		input[type=range]::-webkit-slider-thumb {
			height: 20px;
			width: 20px;
			border-radius: 50%;
			background: #fff;
			box-shadow: 0 0 4px 0 rgba(0, 0, 0, 1);
			cursor: pointer;
			-webkit-appearance: none;
			margin-top: -8px;
		}

		input[type=range]:focus::-webkit-slider-runnable-track {
			background: #03a9f4;
		}

		.range-wrap {
			width: 50%;
			position: absolute;
			margin-left: 25%;
			margin-right: auto;
			bottom: 100px;
		}

		.range-value {
			position: absolute;
			top: -50%;
		}

		.range-value span {
			width: 150px;
			height: 24px;
			line-height: 24px;
			text-align: center;
			background: #03a9f4;
			color: #fff;
			font-size: 12px;
			display: block;
			position: absolute;
			left: 50%;
			transform: translate(-50%, 0);
			border-radius: 6px;
		}

		.range-value span:before {
			content: "";
			position: absolute;
			width: 0;
			height: 0;
			border-top: 10px solid #03a9f4;
			border-left: 5px solid transparent;
			border-right: 5px solid transparent;
			top: 100%;
			left: 50%;
			margin-left: -5px;
			margin-top: -1px;
		}
	</style>
</head>

<body>

	<div id="info">
		<a href="https://immersivecomputing.github.io/EGS_Collab_AR/" target="_blank" rel="noopener">RealTime ERT</a> AR
		<br />
	</div>
	<script type="module">


		let pathPrefix = './';
		//let pathPrefix = './main/';

		// async () => {
		// 	const { THREE } = await import(pathPrefix + 'threejs/build/three.module.js');
		// 	const { ARButton } = await import(pathPrefix + 'threejs/examples/jsm/webxr/ARButton.js');
		// 	const { OrbitControls } = await import(pathPrefix + 'threejs/examples/jsm/controls/OrbitControls.js');
		// 	const { RoomEnvironment } = await import(pathPrefix + 'threejs/examples/jsm/environments/RoomEnvironment.js');
		// 	const { Lut } = await import(pathPrefix + 'threejs/examples/jsm/math/Lut.js');
		// 	const { FontLoader } = await import(pathPrefix + 'threejs/examples/jsm/loaders/FontLoader.js');
		// 	const { LoadOBJ } = await import(pathPrefix + 'LoadSurfaces.js');
		// 	const { LoadVTK } = await import(pathPrefix + 'LoadSurfaces.js');
		// }



		import * as THREE from './threejs/build/three.module.js';
		import { ARButton } from './threejs/examples/jsm/webxr/ARButton.js';
		import { OrbitControls } from './threejs/examples/jsm/controls/OrbitControls.js';
		import { RoomEnvironment } from './threejs/examples/jsm/environments/RoomEnvironment.js';
		import { Lut } from './threejs/examples/jsm/math/Lut.js';
		import { FontLoader } from './threejs/examples/jsm/loaders/FontLoader.js';
		import { LoadOBJ } from './LoadSurfaces.js';
		import { LoadVTK } from './LoadSurfaces.js';
		import { Octokit, App } from "https://cdn.skypack.dev/octokit"; //This is the only dependancy for the GitHub api, can be removed when new endpoint made
		import { GUI } from './threejs/examples/jsm/libs/dat.gui.module.js';


		let container;
		let viewSize, originalAspect;
		let camera, scene, renderer, loadedModel, currentModelGroup, orthoCamera, uiScene, geometryOffsetX, geometryOffsetY;
		let currentFrame = 0;
		let controller, lut, sprite;
		const pointer = new THREE.Vector2();
		let reticle;
		let dataArray = [];
		let hitTestSource = null;
		let hitTestSourceRequested = false;
		const loadedModelParams = {
			opacity: 0.1
		};

		const clipPlaneMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(100,100,100)',
			side: THREE.DoubleSide
		});

		let clipPlanes, clipPlaneObjects, clipPlaneHelpers, clipObject, clipPlaneGeom;
		const clipParams = {
			planeX: {
				constant: 0,
				negated: false,
				displayHelper: false
			},
			planeY: {
				constant: 0,
				negated: false,
				displayHelper: false
			},
			planeZ: {
				constant: 0,
				negated: false,
				displayHelper: false
			}
		};

		FetchData();

		//First fetch all the data
		//This is currently coming in from a GitHub Repo so will need to be changed to the correct endpoint, the object indexing may also need to be changed 

		async function FetchData() {
			const octokit = new Octokit();

			let data = await octokit.request('GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=true', {
				owner: 'immersivecomputing',
				repo: 'EGS_Collab_AR',
				tree_sha: '5044df10a275d5303e190ab1df0cc28ddd6fd5f2'
			});

			const dataArray = [
				[
					"SF_2022_06_09_12_30/SF_2022_06_09_12_30.0.vtk",
					"SF_2022_06_09_12_30/SF_2022_06_09_12_30.1.vtk",
					"SF_2022_06_09_12_30/SF_2022_06_09_12_30.2.vtk",
					"SF_2022_06_09_12_30/SF_2022_06_09_12_30.3.vtk",
					"SF_2022_06_09_12_30/SF_2022_06_09_12_30.4.vtk"
				],
				[
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.0.vtk",
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.1.vtk",
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.2.vtk",
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.3.vtk",
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.4.vtk",
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.5.vtk",
					"SF_2022_06_09_13_00/SF_2022_06_09_13_00.6.vtk"
				],
				[
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.0.vtk",
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.1.vtk",
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.2.vtk",
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.3.vtk",
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.4.vtk",
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.5.vtk",
					"SF_2022_06_09_13_30/SF_2022_06_09_13_30.6.vtk"
				],
				[
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.0.vtk",
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.1.vtk",
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.2.vtk",
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.3.vtk",
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.4.vtk",
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.5.vtk",
					"SF_2022_06_09_14_00/SF_2022_06_09_14_00.6.vtk"
				],
				[
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.0.vtk",
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.1.vtk",
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.2.vtk",
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.3.vtk",
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.4.vtk",
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.5.vtk",
					"SF_2022_06_09_14_30/SF_2022_06_09_14_30.6.vtk"
				],
				[
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.0.vtk",
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.1.vtk",
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.2.vtk",
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.3.vtk",
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.4.vtk",
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.5.vtk",
					"SF_2022_06_09_15_00/SF_2022_06_09_15_00.6.vtk"
				]
			]


			// console.log(data);
			// var counter = 0;
			// for (let i = 0; i < data.data.tree.length; i++) {

			// 	if (data.data.tree[i].type == "tree") {
			// 		dataArray.push(data.data.tree[i]);
			// 		dataArray[counter].vtkFiles = [];
			// 		counter++;
			// 	} else if (data.data.tree[i].type == "blob" && data.data.tree[i].path.includes("vtk")) {
			// 		dataArray[counter - 1].vtkFiles.push(data.data.tree[i].path);
			// 	}
			// }
			// console.log(dataArray);

			//Start loading using ThreeJS
			init();
			animate();
		}


		function init() {


			container = document.createElement('div');
			document.body.appendChild(container);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1;
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.xr.enabled = true;
			renderer.localClippingEnabled = true;
			renderer.autoClear = false;
			container.appendChild(renderer.domElement);

			lut = new Lut();

			scene = new THREE.Scene();

			uiScene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 500);
			camera.position.set(0, 100, 0);
			scene.add(camera);

			viewSize = 2;
			var aspectRatio = window.innerWidth / window.innerHeight;
			originalAspect = window.innerWidth / window.innerHeight;
			orthoCamera = new THREE.OrthographicCamera(-aspectRatio * viewSize / 2, aspectRatio * viewSize / 2, viewSize / 2, -viewSize / 2, 1, 20);
			orthoCamera.position.set(0.95, 0.5, 10);

			const environment = new RoomEnvironment();
			const pmremGenerator = new THREE.PMREMGenerator(renderer);


			sprite = new THREE.Sprite(new THREE.SpriteMaterial({
				map: new THREE.CanvasTexture(lut.createCanvas())
			}));
			sprite.scale.x = 0.0625;
			sprite.scale.y = 0.5;
			uiScene.add(sprite);
			createAxisText(0.05, -0.25, 0, 0, 0, 0, 'cmin', 'cmin', sprite);
			createAxisText(0.05, 0.25, 0, 0, 0, 0, 'cmax', 'cmax', sprite);
			createAxisText(-0.1, -0.05, 0, 0, 0, 90, 'title', 'Bulk Conductivity', sprite);

			loadedModel = new THREE.Group();
			currentModelGroup = new THREE.Group();
			loadedModel.add(currentModelGroup);

			scene.background = null;
			scene.environment = null;

			const light = new THREE.HemisphereLight(0xffffff, 0x080808, 1.5);
			light.position.set(-1.25, 1, 1.25);
			scene.add(light);


			const grid = new THREE.GridHelper(100, 10, 0xffffff, 0xffffff);
			grid.material.opacity = 0.5;
			grid.material.depthWrite = false;
			grid.material.transparent = true;
			grid.visible = true;
			scene.add(grid);

			//clip planes
			clipPlaneObjects = [];
			clipObject = new THREE.Group();
			clipObject.rotation.x = -Math.PI / 2;
			scene.add(clipObject);
			clipPlaneGeom = [
				new THREE.PlaneGeometry(100, 100),
				new THREE.PlaneGeometry(100, 100)
			];
			clipPlanes = [
				new THREE.Plane(new THREE.Vector3(1, 0, 0), 0),
				new THREE.Plane(new THREE.Vector3(0, -1, 0), 0)
			];


			//Load ERT Location data
			LoadERTSensorLocation(loadedModel);

			lut.setColorMap('rainbow');
			lut.setMin(0);

			//plot first time step
			LoadVTKTimeStep(0);

			//Handle axis changes from Visit:
			loadedModel.rotation.set((Math.PI / 180) * -90, 0, 0);
			scene.add(loadedModel);

			//XR Section
			document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

			function onSelect() {

				if (reticle.visible) {

					loadedModel.position.setFromMatrixPosition(reticle.matrix);
					loadedModel.position.set(loadModel.position.x, loadedModel.position.y, loadedModel.position.z + 0.01);
					loadedModel.scale.set(0.0005, 0.0005, 0.0005);
					render();
				}
			}


			controller = renderer.xr.getController(0);
			controller.addEventListener('select', onSelect);
			scene.add(controller);

			reticle = new THREE.Mesh(
				new THREE.RingGeometry(0.15, 0.2, 32).rotateX(- Math.PI / 2),
				new THREE.MeshBasicMaterial()
			);
			reticle.matrixAutoUpdate = false;
			reticle.visible = false;
			scene.add(reticle);
			//end XR Section

			window.addEventListener('resize', onWindowResize);

			//add orbit controls first
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render); // use if there is no animation loop
			controls.minDistance = 0.01;
			controls.maxDistance = 1000;
			controls.target.set(0, 0, 0);
			controls.update();

			//Then add an overlay slider
			var slider = document.getElementById("range");
			slider.step = 1 / (dataArray.length - 1);
			slider.addEventListener("input", loadTimeFrame);

			//Basic GUI
			var gui = new GUI();
			var folder = gui.addFolder('Clipping');
			folder.add(clipParams.planeX, 'constant').name('X-Position').min(-100).max(100).setValue(0).onChange(d => {
				if (clipParams.planeX.negated) {
					clipPlanes[0].constant = d;
				} else {
					clipPlanes[0].constant = -d;
				}
			});
			folder.add(clipParams.planeX, 'constant').name('X-Rotation').min(0).max(180).setValue(0).onChange(d => {
				clipPlanes[0].normal = new THREE.Vector3(Math.cos(Math.PI * d / 180), 0, Math.sin(Math.PI * d / 180));
			});
			folder.add(clipParams.planeY, 'constant').name('Y-Position').min(-50).max(0).setValue(0).onChange(d => {
				if (clipParams.planeY.negated) {
					clipPlanes[1].constant = -d;
				} else {
					clipPlanes[1].constant = d;
				}
			});
			folder.add(clipParams.planeX, 'negated').name('Invert X').onChange(() => {
				clipPlanes[0].negate();
			});
			folder.add(clipParams.planeY, 'negated').name('Invert Y').onChange(() => {
				clipPlanes[1].negate();
			});

			var folder1 = gui.addFolder('Opacity');
			folder1.add(loadedModelParams, 'opacity', 0, 1).name('Opacity').setValue(0.25).onChange(function (value) {
				currentModelGroup.traverse(function (child) {
					if (child.isMesh) {
						child.material.opacity = value;
					}
				});
			});

			console.log(scene);
		}

		function loadTimeFrame(e) {
			var target = (e.target) ? e.target : e.srcElement;
			var scaledTargetValue = parseInt(target.value * (dataArray.length - 1));
			var rangeV = document.getElementById('rangeV');

			var newValue = Number((target.value - target.min) * 100 / (target.max - target.min));
			var newPosition = 10 - (newValue * 0.2);
			rangeV.innerHTML = `<span>${dataArray[scaledTargetValue].path}</span>`;
			rangeV.style.left = `calc(${newValue}% + (${newPosition}px))`;

			if (scaledTargetValue != currentFrame) {
				currentFrame = scaledTargetValue;
				LoadVTKTimeStep(currentFrame);
			}
		}

		function LoadVTKTimeStep(timeStepInt) {

			for (var i = currentModelGroup.children.length - 1; i >= 0; i--) {
				var obj = currentModelGroup.children[i];
				obj.geometry.dispose();
				obj.material.dispose();
				currentModelGroup.remove(obj);
			}

			lut.setMax(dataArray[timeStepInt].length - 1);
			//These are dummy values for now
			updateAxisText('cmin', 1);
			updateAxisText('cmax', dataArray[timeStepInt].length);

			for (let i = 0; i < dataArray[timeStepInt].length; i++) {
				LoadVTK(currentModelGroup, dataArray[timeStepInt][i], dataArray[0].length - (i + 1), lut.getColor(i), clipPlanes);
			}
		}

		function LoadERTSensorLocation(loadedModel) {

			const material = new THREE.MeshBasicMaterial({ color: 0xdba91f });
			const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);

			var sumEastings = 0;
			var sumNorthings = 0;

			const dataTextloader = new THREE.FileLoader();
			dataTextloader.load(pathPrefix + 'ERT_Data/electrodes.txt',
				function (data) {
					var lines = data.split('\n');
					lines.map(function (item) {
						var tabs = item.split('\t');

						if (typeof tabs[1] !== 'undefined') {
							const cube = new THREE.Mesh(geometry, material);
							cube.position.set(tabs[1], tabs[2], tabs[3]);
							loadedModel.add(cube);

							sumEastings = sumEastings + parseFloat(tabs[1]);
							sumNorthings = sumNorthings + parseFloat(tabs[2]);
						}
					});

					geometryOffsetX = sumEastings / (lines.length - 1);
					geometryOffsetY = sumNorthings / (lines.length - 1);

					loadedModel.position.set(-geometryOffsetX, 0, geometryOffsetY);
				}
			);
		}

		function createAxisText(x, y, z, rx, ry, rz, axisName, label, _sprite) {

			const loader = new FontLoader();
			loader.load(pathPrefix + 'threejs/examples/fonts/helvetiker_regular.typeface.json', function (response) {

				var font = response;

				var textGeo = new THREE.TextGeometry(label, {
					size: 0.025,
					height: 0.001,
					curveSegments: 6,
					font: font
				});

				var color = new THREE.Color();
				color.setRGB(255, 250, 250);
				var textMaterial = new THREE.MeshBasicMaterial({ color: color });
				var axisLabel = new THREE.Mesh(textGeo, textMaterial);

				axisLabel.position.x = x;
				axisLabel.position.y = y;
				axisLabel.position.z = -0.05;
				axisLabel.rotation.x = rx * (Math.PI / 180);
				axisLabel.rotation.y = ry * (Math.PI / 180);
				axisLabel.rotation.z = rz * (Math.PI / 180);
				axisLabel.name = axisName;

				_sprite.attach(axisLabel);
			});
		}

		function updateAxisText(axisName, newText) {
			const loader = new FontLoader();
			loader.load(pathPrefix + 'threejs/examples/fonts/helvetiker_regular.typeface.json', function (response) {
				var font = response;

				if (typeof newText == 'string') {
					var textGeo = new THREE.TextGeometry(newText, {
						size: 0.025,
						height: 0.001,
						curveSegments: 6,
						font: font
					});
				} else {
					var textGeo = new THREE.TextGeometry(newText.toFixed(2), {
						size: 0.025,
						height: 0.001,
						curveSegments: 6,
						font: font
					});
				}

				let labelObject = sprite.getObjectByName(axisName);
				labelObject.geometry = textGeo;
			});
		}

		function onWindowResize() {

			var aspect = window.innerWidth / window.innerHeight;
			var change = originalAspect / aspect;
			var newSize = viewSize * change;
			orthoCamera.left = -aspect * newSize / 2;
			orthoCamera.right = aspect * newSize / 2;
			orthoCamera.top = newSize / 2;
			orthoCamera.bottom = -newSize / 2;
			orthoCamera.updateProjectionMatrix();

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function onPointerMove(event) {

			pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
			pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

		}

		//Run the animation frames
		function animate() {
			renderer.setAnimationLoop(render);
		}

		function render(timestamp, frame) {
			//Handle any XR session needs
			if (frame) {

				const referenceSpace = renderer.xr.getReferenceSpace();
				const session = renderer.xr.getSession();

				if (hitTestSourceRequested === false) {
					session.requestReferenceSpace('viewer').then(function (referenceSpace) {
						session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
							hitTestSource = source;
						});
					});

					session.addEventListener('end', function () {
						hitTestSourceRequested = false;
						hitTestSource = null;
					});
					hitTestSourceRequested = true;
				}

				if (hitTestSource) {
					const hitTestResults = frame.getHitTestResults(hitTestSource);
					if (hitTestResults.length) {
						const hit = hitTestResults[0];
						reticle.visible = true;
						reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
					} else {
						reticle.visible = false;
					}
				}
			}

			//Render the frame
			renderer.clear();
			renderer.render(scene, camera);
			renderer.render(uiScene, orthoCamera);
		}

	</script>


	<div class="range-wrap">
		<div class="range-value" id="rangeV"></div>
		<input id="range" type="range" min="0" max="1" value="0" step="0.01">
	</div>
</body>

</html>